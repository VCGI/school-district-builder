# **School District Builder \- Technical Documentation**

This document provides a technical overview of the Vermont School District Builder application, including its architecture, key libraries, and deployment process.

## **1\. Project Overview**

The School District Builder is a single-page application (SPA) built with React and TypeScript. It allows users to interactively create and analyze custom school district maps for Vermont. The application is designed to be entirely client-side, with all data processing and state management handled within the user's browser.

The core functionality revolves around fetching GeoJSON data for Vermont towns, allowing users to assign these towns to districts, and then calculating and displaying relevant statistics for those districts. The application state, including all assignments and custom names, can be serialized into a compressed string, which is then used to generate a shareable URL.

## **2\. Core Technologies & Libraries**

This project was built with a modern, lightweight tech stack suitable for a client-side mapping application.

* [**React**](https://reactjs.org/)\*\* (v18):\*\* The core UI library used to build the application's components. The project uses functional components and hooks for state management and side effects.  
* [**Vite**](https://vitejs.dev/)**:** The build tool and development server. Vite provides an extremely fast development experience with Hot Module Replacement (HMR) and bundles the application for production with optimized static assets.  
* [**TypeScript**](https://www.typescriptlang.org/)**:** A superset of JavaScript that adds static typing. TypeScript helps catch errors early and makes the codebase more robust and self-documenting.  
* [**Leaflet**](https://leafletjs.com/)**:** A lightweight, open-source JavaScript library for creating interactive maps. It is used to render the Vermont town boundaries (GeoJSON) and handle user interactions like clicking and hovering on towns.  
* [**Tailwind CSS**](https://tailwindcss.com/)**:** A utility-first CSS framework used for all styling. It allows for rapid UI development without writing custom CSS.  
* [**Pako**](https://github.com/nodeca/pako)**:** A JavaScript library for zlib compression. It is used to compress the application's state (district assignments, names, etc.) into a compact string for the shareable URL, ensuring the URL does not become excessively long.  
* [**html2canvas**](https://html2canvas.hertzen.com/)**:** A library that takes "screenshots" of web pages or parts of it, directly on the user's browser. It is used for the "Export to JPG" functionality.

## **3\. Project Structure**

The repository is organized into several key directories:

/  
├── deployment/         \# Contains files for deployment, like the root redirect.  
├── dist/               \# The output directory for the production build (generated by \`npm run build\`).  
├── public/             \# Static assets that are copied directly to the build output.  
├── src/  
│   ├── components/     \# Reusable React components (LeftSidebar, MapComponent, etc.).  
│   ├── App.tsx         \# The main application component where state and logic are managed.  
│   ├── index.css       \# Global styles and Tailwind CSS imports.  
│   ├── index.tsx       \# The entry point for the React application.  
│   ├── constants.ts    \# Application-wide constants (URLs, colors, max districts).  
│   └── types.ts        \# TypeScript type definitions and interfaces.  
├── .gitignore  
├── index.html          \# The main HTML template for the application.  
├── package.json        \# Project dependencies and scripts.  
└── README.md           \# The main project README file.

## **4\. Deployment Guide to Azure Blob Storage**

The application is deployed as a static site to an Azure Blob Storage container configured for static website hosting. The deployment strategy uses versioned folders to ensure that old, shared links never break.

### **Step 1: Build the Application**

From the root of the project directory, run the build command:

npm run build

This command will create a dist folder containing all the necessary static files (index.html, JavaScript, CSS).

### **Step 2: Prepare the Redirect File**

To ensure users are always directed to the latest version of the application, a redirect file is used at the root of the website.

1. Create a folder named deployment in the root of your project.  
2. Inside deployment, create an index.html file with the following content. **Remember to update the version number (v02 in this example) each time you deploy a new version.**  
   \<\!DOCTYPE html\>  
   \<html\>  
   \<head\>  
     \<title\>Redirecting...\</title\>  
     \<meta http-equiv="refresh" content="0; url=./v02/" /\>  
     \<link rel="canonical" href="./v02/" /\>  
   \</head\>  
   \<body\>  
     \<p\>If you are not redirected automatically, follow this \<a href="./v02/"\>link to the latest version\</a\>.\</p\>  
   \</body\>  
   \</html\>

### **Step 3: Upload Files to Azure**

1. **Navigate to your Azure Storage Account** and select the $web container.  
2. **Create a new "folder"** for the new version (e.g., v02).  
3. **Upload the contents of the dist folder** (from Step 1\) into the new version folder (e.g., into /education/district-builder/v02/).  
4. **Upload the redirect index.html file** (from Step 2\) to the root path: /education/district-builder/. Overwrite the existing file if one is present.

By following this process, the main URL will always redirect to the latest version, while direct links to older versioned URLs will continue to work indefinitely.

## **5\. Data Source**

The geographic and school data used in this application is sourced from a GeoJSON file in VCGI's AWS open data bucket:  
https://s3.us-east-2.amazonaws.com/vtopendata-prd/\_Other/Education/VT\_School\_Geo.json  
This single file contains all the necessary town boundaries, school locations, and demographic data required for the application to function.